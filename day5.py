def fib(n):
    if n==0:
        return 0
    if n==1:
        return 1

    if n>1:
        num=fib(n-1)+fib(n-2)
        
        return num    

def move(n, a, b, c):
    if n==1:
        print ("move", a, "-->", c)
    else:
        move(n-1, a, c, b)
        move(1, a, b, c)
        move(n-1, b, a, c)

move(5, "A", "B", "C" )

"""
首先要将汉诺塔能够成功挪动的逻辑理清，'A', 'B', 'C'柱 与 a, b, c不是一直固定的对应关系。

n=1的时候如下

if n == 1:
    print(a, '-->', c)      #  a --> c
n>1的时候如下

# ABC与abc的对应关系是一直在变的，而相对的，要将第n块从a挪到c，那就要先将第n-1块从a挪到b，挪动了第n块之后再将第n-1块从b挪到c。

a --> b : (n-1), a --> c : (n), b --> c (n-1)，也就是要移动n的话，需要先移动n-1然后再移动n，移动了n之后再移动n-1。

    else:
        move(n-1, a, c, b) # 借助c对应的柱，将n-1个圆盘从a对应的柱移动到b对应的柱  a --> b
        print(a, '-->', c) # 将a对应的柱最底层的圆盘移动到c对应的柱              a --> c
        move(n-1, b, a, c) # 借助a对应的柱，将n-1个圆盘从b对应的柱移动到c对应的柱  b --> c
1、当n>1的时候，如果是从A柱全部挪到C柱，那就先要将A柱上的除最后的一块圆盘之上的前n-1块全部挪到B柱上，然后将第n块圆盘挪到C柱上。

- 这时候对应关系是A - a, B - b, C - c，也就是A柱借助B柱将第n块挪到C柱上，且A柱上的前n-1块要全部挪到B柱上。

2、之后将A柱上的第n块挪到C柱上。

3、从A柱上将n-1块圆盘挪到B柱上的时候是需要借助C柱的，也就是需要将第n-1块圆盘挪到B柱上，那就要将n-2块全部挪到C柱上，因为第n-1块是在A柱上的。

- 这时候对应关系是A - a, C - b, B - c，也就是A柱借助C柱将第n-1块挪到B柱上，且A柱上的前n-2块要全部挪到C柱上。

4、之后将A柱上的第n-1块挪到B柱上。

5、此刻，前n-1块圆盘都到了B柱上，第n-1块也是在B柱上的，B柱借助A柱将第n-1块挪到C柱上的第n块之上。

- 这时候对应关系是C - a, A - b, B - c，也就是C柱借助A柱将第n-2块挪到B柱上，且A柱上的前n-2块要全部挪到C柱上。

6、之后将C柱上的第n-2块挪到B柱上。

过程推导

举例：(4-1, a, c, b)，实际应该是(n-1, a, c, b)，这么写只是为了清楚。

(4-1, a, c, b)"ACB" —— 此刻 ABC与abc的对应关系，也就是 A - a, B - c, C - b

但从程序逻辑来看，看的一直是相对关系，所以记成 a - A, c - B , b - C，这样方便接下来理清过程

因为a b c之间挪动圆盘的逻辑关系一直是不变的，但a, b, c对应的'A', 'B', 'C'是一直在变的

注1：【】中是输出的先后顺序，【1】是第一个，【8】是第八个。可以运行答案中的代码试一下，n=4时对应的顺序和如下是一样的。

注2：其中 1、 2、等等是程序运行的顺序。
"""